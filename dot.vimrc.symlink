
" General settings
"
echo "(>^.^<)"
set nocompatible
set number

" Autoread files whenever they are being changed outside vim
set autoread
filetype off

" Settings
set rtp+=~/.vim/bundle/Vundle.vim
set number
set encoding=utf-8

" set columns=93
set autoread
set autowrite

" indentation
set sts=4
set ts=4
set sw=4

set updatetime=100

let @s="100|2hbi\"\\\<CR>f\"\<Esc>"

" Set syntastic checker be pylint
" let g:syntastic_python_checkers = ['pylint']

" Highlight the focused window by enabling numbers in margin
augroup BgHighlight
    autocmd!
    autocmd WinEnter * set number
    autocmd WinLeave * setlocal nonumber
augroup END

syn keyword pythonBuiltin self

set statusline=%f

" Keymappings
let mapleader = ","

nnoremap <leader>r :checktime<CR>:so $MYVIMRC<CR>
nnoremap <leader>p :vertical resize 93<CR>
nnoremap <leader>s :Rg <CR>
nnoremap <leader>v :e $MYVIMRC<CR>
nnoremap <leader>V :!e $MYVIMRC<CR>
nnoremap <leader>w :w <cr>
nnoremap <leader>b :Black <cr>
" nnoremap <leader>l :Black <cr> :w <cr> :SyntasticCheck <cr> :echo "saved" <cr>
noremap / :set hlsearch <cr> /
noremap <leader>/ :set hlsearch!<CR>
noremap <leader><C-V> :set paste!<CR>
nnoremap <leader>j J

nmap <C-n> :NERDTreeToggle<CR>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <C-B>  :YcmCompleter GoToDeclaration <CR>
nnoremap <C-S>  :YcmCompleter config.yaml GoToDeclaration <CR>


" Turbomove
noremap J 5j
noremap K 5k
noremap L 5l
noremap H 5h

inoremap jk <ESC>
inoremap JK <ESC>

" Abbreviations
iabbr bp import pdb; pdb.set_trace()

" source .vimrc after saving it
au bufwritepost .vimrc source $MYVIMRC
au bufwritepre * :%s/\s\+$//e


" PEP8
au Filetype python
    \ set tabstop=4 |
    \ set softtabstop=4 |
    \ set shiftwidth=4 |
    \ set expandtab |
    \ set autoindent |
    \ set fileformat=unix |

call vundle#begin()
" Add plugins here
Plugin 'VundleVim/Vundle.vim'

" Send to pane only for tmux
" Plugin 'vim-slime'
Plugin 'jpalardy/vim-slime'

" Nerdtree
Plugin 'scrooloose/nerdtree'

" Proper indentation
Plugin 'vim-scripts/indentpython.vim'

" Highligt first unique letter in each word when using f or t
Plugin 'unblevable/quick-scope'

" Colorscheme
Plugin 'morhetz/gruvbox'

" Black
Plugin 'psf/black'

" Rg
Plugin 'junegunn/fzf', { 'do': './install --bin' }

"fzf
Plugin 'junegunn/fzf.vim'

Plugin 'tpope/vim-surround'
"documentation generation
Plugin 'kkoomen/vim-doge', { 'do': { -> doge#install() } }

" for linting
Plugin 'vim-syntastic/syntastic'

" autocompletion of paranthesis
Plugin 'Krasjet/auto.pairs'

Plugin 'junegunn/vim-easy-align'

" Autocompletion and jump to definition
Bundle 'Valloric/YouCompleteMe'
"
call vundle#end()

    nnoremap <c-t> :Tags<cr>
    nnoremap <c-g> :RG<cr>
    nnoremap <silent><c-f> :Files<CR>
    " nnoremap <c-b> :Buffers<cr>

filetype plugin indent on

let g:slime_target = "tmux"
let g:slime_default_config = {"socket_name": "default", "target_pane": 1}

let g:doge_doc_standard_python='google'

" Plugin Settings
colorscheme gruvbox
set background=dark
syn keyword pythonExceptions self
set t_Co=256

let g:NERDTreeWinSize=37

let g:ycm_autoclose_preview_window_after_insertion = 1
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)


" CREATE FLOATING WINDOW {{{
function! CreateCenteredFloatingWindow()
  let width  = float2nr(&columns * 0.9)
  let height = float2nr(&lines * 0.8)
  let top    = ((&lines - height) / 2) - 1
  let left   = (&columns - width) / 2
  let opts   = { 'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal' }
  let top    = "╭" . repeat("─", width - 2) . "╮"
  let mid    = "│" . repeat(" ", width - 2) . "│"
  let bot    = "╰" . repeat("─", width - 2) . "╯"
  let lines  = [top] + repeat([mid], height - 2) + [bot]
  let s:buf  = nvim_create_buf(v:false, v:true)

  call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
  call nvim_open_win(s:buf, v:true, opts)
  set winhl=Normal:Floating

  call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, CreatePadding(opts))
  autocmd BufWipeout <buffer> exe 'bwipeout '.s:buf
endfunction

function! CreatePadding(opts)
  let a:opts.row    += 1
  let a:opts.height -= 2
  let a:opts.col    += 2
  let a:opts.width  -= 4
  return a:opts
endfunction
" }}}


" FZF
let $FZF_DEFAULT_COMMAND = 'rg --files --no-ignore-vcs --hidden -g "!{node_modules,.git}"'

command! -bang -nargs=? -complete=dir Files
\ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--margin=1,2']}), <bang>0)

let g:fzf_layout = { 'window': 'call CreateCenteredFloatingWindow()' }
" let g:fzf_action = {
"       \ 'ctrl-s': 'split',
"       \ 'ctrl-v': 'vsplit',
"       \ 'ctrl-t': 'tab split' }
"
" let g:fzf_colors = {
"       \ 'fg':      ['fg', 'Normal'],
"       \ 'bg':      ['bg', 'Normal'],
"       \ 'hl':      ['fg', 'Keyword'],
"       \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'PreProc'],
"       \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
"       \ 'hl+':     ['fg', 'Keyword'],
"       \ 'info':    ['fg', 'Statement'],
"       \ 'border':  ['fg', 'Comment'],
"       \ 'prompt':  ['fg', 'Conditional'],
"       \ 'pointer': ['fg', 'Statement'],
"       \ 'marker':  ['fg', 'Keyword'],
"       \ 'spinner': ['fg', 'Label'],
"       \ 'header':  ['fg', 'Keyword'] }
"
" function! RipgrepFzf(query, fullscreen)
"   let command_fmt     = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
"   let initial_command = printf(command_fmt, shellescape(a:query))
"   let reload_command  = printf(command_fmt, '{q}')
"   let spec            = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command, '--layout=reverse', '--margin=1,2']}
"   call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
" endfunction
" command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)
"
"
" Put plugins and dictionaries in this dir (also on Windows)
let vimDir = '$HOME/.vim'

if stridx(&runtimepath, expand(vimDir)) == -1
  " vimDir is not on runtimepath, add it
  let &runtimepath.=','.vimDir
endif

" Keep undo history across sessions by storing it in a file
if has('persistent_undo')
    let myUndoDir = expand(vimDir . '/undodir')
    " Create dirs
    :silent call system('mkdir ' . vimDir)
    :silent call system('mkdir ' . myUndoDir)
    let &undodir = myUndoDir
    set undofile
endif


